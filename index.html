<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Operator Performance Report</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; padding: 18px; background:#f7fafc; color:#111; }
    h2 { margin: 0 0 12px; }
    .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    input[type="date"], select { padding:8px 10px; border-radius:6px; border:1px solid #d1d5db; }
    button { padding:9px 12px; background:#2563eb; color:#fff; border:0; border-radius:8px; cursor:pointer; font-weight:600; }
    button:disabled { opacity:.6; cursor:not-allowed; }

    .card { background:#fff; padding:14px; border-radius:10px; border:1px solid #e6e9ef; margin-bottom:14px; }
    table { width:100%; border-collapse:collapse; margin-top:10px; font-size:13px; }
    th, td { padding:8px; text-align:center; }

    /* Report header */
    .report-header { border:1px solid #000; border-radius:6px; padding:10px 20px; margin-bottom:20px; background:#fff; }
    .header-top { display:flex; justify-content:space-between; align-items:center; }
    .header-top img { max-height:60px; width:auto; }
    .header-center { text-align:center; flex:1; }
    .header-center h1 { margin:0; font-size:22px; font-weight:bold; }
    .header-center h3 { margin:4px 0 0; font-size:14px; font-weight:normal; }
    .header-center h2 { margin:6px 0 0; font-size:18px; font-weight:bold; }
    .header-bottom { display:flex; justify-content:space-between; font-size:13px; margin-top:6px; font-weight:bold; }

    /* Screenshot-like styling for Machine Performance */
    .kpiTable, .gridTable { border:2px solid #555; }
    .kpiTable th, .kpiTable td, .gridTable th, .gridTable td { border:1px solid #555; }
    .kpiTable thead tr, .gridTable thead tr { background:#e5e7eb; font-weight:700; }
    .kpiTable td { height:34px; }

    /* Generic tables */
    .boxed { border:1px solid #999; }
    .boxed th, .boxed td { border:1px solid #999; }
    .boxed thead tr { background:#f8fafc; font-weight:700; }

    .muted { color:#6b7280; font-size:13px; }
    .small { font-size:12px; color:#6b7280; }
    .error { color:#991b1b; background:#fff1f2; padding:8px; border-radius:6px; border:1px solid #fecaca; margin-top:8px; display:none; }
    pre { background:#f3f4f6; padding:8px; border-radius:6px; overflow:auto; max-height:180px; display:none; }
  </style>
</head>
<body>

  <!-- Date Selection -->
  <div class="controls">
    <label for="datePicker">Date</label>
    <input id="datePicker" type="date" />
    <label for="operatorSelect">Operator</label>
    <select id="operatorSelect"><option value="">-- Select Operator --</option></select>
    <button id="generateBtn">Generate</button>
    <div id="status" class="small muted" style="margin-left:12px"></div>
  </div>

  <!-- Report Section -->
  <div id="reportSection" style="display:none;">
    <div class="report-header" id="reportHeader">
      <div class="header-top">
        <img src="PlantwizLogo.png" alt="Plantwiz Logo">
        <div class="header-center">
          <h1>Pima Controls Pvt. Ltd</h1>
          <h3>Block No.298, Nr.Bacha Motors, Sanathal Cross Road, Ahmedabad(382210)</h3>
          <h2>Operator Performance Report</h2>
        </div>
        <img src="PimaLogo.png" alt="Pima Logo">
      </div>
      <div class="header-bottom">
        <span id="headerDate">Date: --</span>
        <span id="headerOperator">Operator Name: --</span>
        <span id="generatedDate">Report Generated ON: --</span>
      </div>
    </div>

    <div id="errorBox" class="error"></div>
    <div id="reportOutput"></div>
    <pre id="debugOutput"></pre>
  </div>

  <script>
    /* -------- Config -------- */
    const DEVICE_ID = "991cf500-661a-11f0-90f1-775fee303094";
    const API_BASE = "https://plantwiz.pimateck.in/api";
    const qs = new URLSearchParams(window.location.search);
    const TOKEN = qs.get('token') || "";

    /* -------- DOM -------- */
    const datePicker = document.getElementById('datePicker');
    const operatorSelect = document.getElementById('operatorSelect');
    const btnGenerate = document.getElementById('generateBtn');
    const status = document.getElementById('status');
    const errorBox = document.getElementById('errorBox');
    const reportSection = document.getElementById('reportSection');
    const reportOutput = document.getElementById('reportOutput');
    const debugOutput = document.getElementById('debugOutput');

    /* -------- Utils -------- */
    function showError(msg) { if (!msg) { errorBox.style.display='none'; errorBox.textContent=''; return; } errorBox.style.display='block'; errorBox.textContent=msg; }
    function setStatus(txt) { status.textContent = txt || ''; }
    function safeNum(v){ if(v===undefined || v===null) return NaN; const n = typeof v==='number'? v : parseFloat(String(v).replace(',','')); return Number.isFinite(n)? n : NaN; }
    function normalizeToMinute(ts){ const d = new Date(+ts); d.setSeconds(0,0); return d.getTime(); }

    /* -------- Keys -------- */
    const KEYS_LIST = [
      "SKU","Operator_Name",
      "Machine_Speed","Standard_Speed","Good_Production",
      "Runtime","Downtime","Idletime",
      "deltaperformance","deltaavailability","deltaoee","deltaquality",
      "Planned_Production_Time",
      "Per_Min_Consumption",
      "Downtime_Submit","Downtime_Duration","Downtime_Reason_Code"
    ];
    const KEYS_PARAM = KEYS_LIST.join(',');

    /* -------- Data layer -------- */
    async function fetchTelemetryForDate(dateStr) {
      if (!TOKEN) throw new Error("Missing token in URL (?token=YOUR_JWT)");
      const start = new Date(dateStr + "T00:00:00").getTime();
      const end   = new Date(dateStr + "T23:59:59").getTime();
      const url = `${API_BASE}/plugins/telemetry/DEVICE/${DEVICE_ID}/values/timeseries?keys=${encodeURIComponent(KEYS_PARAM)}&startTs=${start}&endTs=${end}&interval=60000&limit=5000`;
      const res = await fetch(url, { headers: { "X-Authorization": `Bearer ${TOKEN}` } });
      if (!res.ok) { const txt = await res.text().catch(()=>res.statusText); throw new Error(\`Telemetry fetch failed: \${res.status} \${txt}\`); }
      return res.json();
    }

    function buildRowsFromTimeseries(tsObj) {
      const map = new Map();
      Object.entries(tsObj || {}).forEach(([key, arr])=>{
        (arr||[]).forEach(p=>{
          const minute = normalizeToMinute(p.ts);
          const row = map.get(minute) || { ts: minute };
          row[key] = p.value;
          map.set(minute, row);
        });
      });
      return Array.from(map.values()).sort((a,b)=>a.ts-b.ts);
    }

    async function loadOperators(dateStr) {
      try {
        showError(''); setStatus('Loading operators…');
        operatorSelect.innerHTML = '<option value="">Loading…</option>';
        const ts = await fetchTelemetryForDate(dateStr);
        const ops = (ts.Operator_Name || []).map(x=>String(x.value).trim()).filter(Boolean);
        const unique = [...new Set(ops)];
        operatorSelect.innerHTML = '<option value="">-- Select Operator --</option>';
        unique.forEach(op => operatorSelect.appendChild(new Option(op, op)));
        setStatus(unique.length ? \`Found \${unique.length} operator(s)\` : 'No operators found');
      } catch (err) {
        operatorSelect.innerHTML = '<option value="">-- Select Operator --</option>';
        showError(err.message || String(err)); setStatus('');
      }
    }

    /* -------- Init -------- */
    datePicker.addEventListener('change', () => { setStatus(''); showError(''); if (datePicker.value) loadOperators(datePicker.value); });
    btnGenerate.addEventListener('click', generateReport);
    (function initToday(){ const d=new Date(); const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0'); datePicker.value=\`\${y}-\${m}-\${day}\`; if(datePicker.value) loadOperators(datePicker.value).catch(()=>{}); })();

    /* -------- Report -------- */
    async function generateReport() {
      showError(''); reportOutput.innerHTML=''; debugOutput.style.display='none';

      const dateStr = datePicker.value;
      const operator = operatorSelect.value;
      if (!dateStr) { showError('Please select a date.'); return; }
      if (!operator) { showError('Please select an operator.'); return; }

      // Show header
      reportSection.style.display='block';
      document.getElementById('headerDate').textContent = \`Date: \${dateStr}\`;
      document.getElementById('headerOperator').textContent = \`Operator Name: \${operator}\`;
      document.getElementById('generatedDate').textContent = \`Report Generated ON: \${new Date().toLocaleString()}\`;

      try {
        setStatus('Fetching telemetry and computing…');
        const ts = await fetchTelemetryForDate(dateStr);
        const allRows = buildRowsFromTimeseries(ts);

        // Filter for selected operator
        const rows = allRows.filter(r => (r.Operator_Name ? String(r.Operator_Name).trim() : '') === operator);
        if (!rows.length) {
          reportOutput.innerHTML = `<div class="card"><div class="muted">No records found for ${operator} on ${dateStr}.</div></div>`;
          setStatus(''); return;
        }

        /* ----- Aggregations common ----- */
        // SKU wise
        const skuAgg = {};
        let totalRuntime = 0, totalDowntime = 0, totalIdle = 0;
        let actualProduction = 0, goodProduction = 0, plannedProduction = 0, plannedTime = 0;
        let sumPerf=0,cntPerf=0,sumAvail=0,cntAvail=0,sumOee=0,cntOee=0,sumQual=0,cntQual=0;

        // Energy buckets
        let ecRuntime=0, ecDowntime=0, ecIdle=0, ecTotal=0;

        // Downtime aggregation
        const dtMap = new Map(); // code -> {durationMin, count}
        let totalFailures = 0;

        rows.forEach(r=>{
          const sku = (r.SKU && String(r.SKU).trim()) || 'UNSPECIFIED';
          const ms = safeNum(r.Machine_Speed);
          const std= safeNum(r.Standard_Speed);
          const gp = safeNum(r.Good_Production);
          const rt = safeNum(r.Runtime);
          const dt = safeNum(r.Downtime);
          const it = safeNum(r.Idletime);

          if(!skuAgg[sku]) skuAgg[sku] = { production:0, runtime:0, downtime:0, idletime:0 };
          skuAgg[sku].production += Number.isFinite(ms)? ms:0;
          skuAgg[sku].runtime   += Number.isFinite(rt)? rt:0;
          skuAgg[sku].downtime  += Number.isFinite(dt)? dt:0;
          skuAgg[sku].idletime  += Number.isFinite(it)? it:0;

          actualProduction += Number.isFinite(ms)? ms:0;
          plannedProduction += Number.isFinite(std)? std:0;
          goodProduction += Number.isFinite(gp)? gp:0;

          totalRuntime  += Number.isFinite(rt)? rt:0;
          totalDowntime += Number.isFinite(dt)? dt:0;
          totalIdle     += Number.isFinite(it)? it:0;

          const ppt = safeNum(r.Planned_Production_Time);
          if (Number.isFinite(ppt)) plannedTime = ppt;

          const dperf = safeNum(r.deltaperformance);  if (Number.isFinite(dperf)) { sumPerf += dperf; cntPerf++; }
          const dav   = safeNum(r.deltaavailability); if (Number.isFinite(dav))   { sumAvail += dav; cntAvail++; }
          const doee  = safeNum(r.deltaoee);          if (Number.isFinite(doee))  { sumOee  += doee;  cntOee++; }
          const dqual = safeNum(r.deltaquality);      if (Number.isFinite(dqual)) { sumQual += dqual; cntQual++; }

          // Energy buckets by state flags (1 per minute)
          const perMin = safeNum(r.Per_Min_Consumption);
          if (Number.isFinite(perMin)) {
            const isRT = Number.isFinite(rt) && rt === 1;
            const isDT = Number.isFinite(dt) && dt === 1;
            const isID = Number.isFinite(it) && it === 1;
            if (isRT) ecRuntime += perMin;
            else if (isDT) ecDowntime += perMin;
            else if (isID) ecIdle += perMin;
            ecTotal += perMin;
          }

          // Downtime end events
          const submit = safeNum(r.Downtime_Submit);
          if (submit === 1) {
            const durSec = safeNum(r.Downtime_Duration); // seconds
            const code = (r.Downtime_Reason_Code && String(r.Downtime_Reason_Code).trim()) || 'UNSPECIFIED';
            const durMin = Number.isFinite(durSec) ? (durSec/60) : 0; // convert seconds -> minutes
            const cur = dtMap.get(code) || { durationMin:0, count:0 };
            cur.durationMin += durMin;
            cur.count += 1;
            dtMap.set(code, cur);
            totalFailures += 1;
          }
        });

        const avgPerf = cntPerf ? (sumPerf/cntPerf) : NaN;
        const avgAvail = cntAvail ? (sumAvail/cntAvail) : NaN;
        const avgOee = cntOee ? (sumOee/cntOee) : NaN;
        const computedQuality = actualProduction>0 ? (goodProduction/actualProduction*100) : NaN;
        const displayQuality = cntQual ? (sumQual/cntQual) : computedQuality;

        /* ---------- Build HTML ---------- */
        let html = '';

        // 1) Production Details (SKU-wise)
        html += `<div class="card"><h3>2. Production Details (SKU-wise)</h3>
          <table class="boxed">
            <thead><tr>
              <th>SKU Name</th><th>Production (Units)</th><th>Runtime (hrs)</th><th>Downtime (hrs)</th><th>Idletime (hrs)</th>
            </tr></thead><tbody>`;
        Object.keys(skuAgg).forEach(sku=>{
          const d = skuAgg[sku];
          html += `<tr>
            <td>${sku}</td>
            <td>${Number(d.production).toFixed(2)}</td>
            <td>${(Number(d.runtime)/60).toFixed(2)}</td>
            <td>${(Number(d.downtime)/60).toFixed(2)}</td>
            <td>${(Number(d.idletime)/60).toFixed(2)}</td>
          </tr>`;
        });
        html += `</tbody></table></div>`;

        // 2) Machine Performance Summary (like screenshot)
        html += `<div class="card"><h3>3. Machine Performance Summary</h3>
          <table class="kpiTable">
            <thead><tr><th>OEE</th><th>Performance</th><th>Availability</th><th>Quality</th></tr></thead>
            <tbody><tr>
              <td>${Number.isFinite(avgOee)? avgOee.toFixed(0)+'%' : '--'}</td>
              <td>${Number.isFinite(avgPerf)? avgPerf.toFixed(0)+'%' : '--'}</td>
              <td>${Number.isFinite(avgAvail)? avgAvail.toFixed(0)+'%' : '--'}</td>
              <td>${Number.isFinite(displayQuality)? Number(displayQuality).toFixed(0)+'%' : '--'}</td>
            </tr></tbody>
          </table>
          <table class="gridTable" style="margin-top:14px;">
            <thead><tr><th>Performance</th><th>Availability</th><th>Quality</th></tr></thead>
            <tbody>
              <tr>
                <td>Planned Production: ${Number.isFinite(plannedProduction)? plannedProduction.toLocaleString() : '--'}</td>
                <td>Planned Production Time: ${Number.isFinite(plannedTime)? plannedTime.toFixed(0) : '--'} min</td>
                <td>Actual Production: ${actualProduction.toLocaleString()}</td>
              </tr>
              <tr>
                <td>Actual Production: ${actualProduction.toLocaleString()}</td>
                <td>Runtime: ${(totalRuntime).toFixed(0)} min</td>
                <td>Good Production: ${goodProduction.toLocaleString()}</td>
              </tr>
              <tr>
                <td></td>
                <td>Downtime: ${(totalDowntime).toFixed(0)} min</td>
                <td></td>
              </tr>
            </tbody>
          </table>
        </div>`;

        // 3) Alarms & Downtimes During Operation (Downtime Summary + Overall MTBF/MTTR)
        // MTBF = totalRuntime / totalFailures ; MTTR = sumDurations / totalFailures
        const totalDurMinFromEvents = Array.from(dtMap.values()).reduce((s,v)=>s+v.durationMin,0);
        const overallMTBF = totalFailures ? (totalRuntime / totalFailures) : 0;           // minutes
        const overallMTTR = totalFailures ? (totalDurMinFromEvents / totalFailures) : 0;  // minutes

        html += `<div class="card"><h3>4. Alarms & Downtimes During Operation</h3>
          <h4 style="text-align:left;margin:4px 0;">Downtime Summary</h4>
          <table class="boxed">
            <thead><tr>
              <th>Downtime ID</th><th>Downtime Reason</th><th>Downtime Duration (min)</th><th>No. of Times</th><th>MTBF (min)</th><th>MTTR (min)</th>
            </tr></thead><tbody>`;

        // For MTBF per code we use: totalRuntime / occurrences for that code
        if (dtMap.size === 0){
          html += `<tr><td colspan="6">No downtime records (submit=1) for this operator on ${dateStr}.</td></tr>`;
        } else {
          dtMap.forEach((v,code)=>{
            const mttr = v.count ? (v.durationMin / v.count) : 0;
            const mtbf = v.count ? (totalRuntime / v.count) : 0;
            html += `<tr>
              <td>${code}</td>
              <td>${code}</td>
              <td>${v.durationMin.toFixed(1)}</td>
              <td>${v.count}</td>
              <td>${mtbf.toFixed(0)}</td>
              <td>${mttr.toFixed(1)}</td>
            </tr>`;
          });
        }
        html += `</tbody></table>
          <div style="text-align:left;margin-top:8px;">
            <strong>Overall Operator MTBF:</strong> ${overallMTBF.toFixed(0)} min &nbsp; | &nbsp;
            <strong>Overall Operator MTTR:</strong> ${overallMTTR.toFixed(1)} min
          </div>
        </div>`;

        // 4) Energy Consumption & Losses
        const pct = (part,total)=> total>0 ? ((part/total)*100).toFixed(0)+'%' : '--';
        html += `<div class="card"><h3>5. Energy Consumption & Losses</h3>
          <table class="boxed">
            <thead><tr><th>Category</th><th>Energy Consumed (kWh)</th><th>% of Total Consumption</th><th>Remarks</th></tr></thead>
            <tbody>
              <tr><td>Runtime Consumption</td><td>${ecRuntime.toFixed(2)}</td><td>${pct(ecRuntime,ecTotal)}</td><td>Productive Energy Use</td></tr>
              <tr><td>Downtime Consumption</td><td>${ecDowntime.toFixed(2)}</td><td>${pct(ecDowntime,ecTotal)}</td><td>Energy Lost during Downtime</td></tr>
              <tr><td>Idle Consumption</td><td>${ecIdle.toFixed(2)}</td><td>${pct(ecIdle,ecTotal)}</td><td>Standby Loss</td></tr>
              <tr><th>Total</th><th>${ecTotal.toFixed(2)}</th><th>100%</th><th>-</th></tr>
            </tbody>
          </table>
        </div>`;

        // 5) Supervisor Insights
        // Find top recurring downtime code
        let topCode = null, topCount = 0, topDur=0, topMtbf=0, topMttr=0;
        dtMap.forEach((v,code)=>{ if(v.count>topCount){ topCount=v.count; topCode=code; topDur=v.durationMin; } });
        if (topCode){
          topMttr = topCount ? (topDur/topCount) : 0;
          topMtbf = topCount ? (totalRuntime/topCount) : 0;
        }
        const oeeDisp = Number.isFinite(avgOee)? avgOee.toFixed(1) : '--';
        const qualDisp = Number.isFinite(displayQuality)? Number(displayQuality).toFixed(1) : '--';

        html += `<div class="card"><h3>6. Supervisor Insights</h3>
          <ul style="text-align:left;line-height:1.6;">
            <li><strong>Quality Performance:</strong> Quality at <strong>${qualDisp}%</strong> with low defects relative to production volume.</li>
            <li><strong>Downtime Analysis:</strong> ${
              topCode ? `Most frequent downtime: <strong>${topCode}</strong> (${topCount} occurrences). MTBF = ${topMtbf.toFixed(0)} min | MTTR = ${topMttr.toFixed(1)} min.` : 'No downtime events recorded.'
            }</li>
            <li><strong>OEE Review:</strong> Current OEE is <strong>${oeeDisp}%</strong>. Focus on reducing unplanned stops to lift Availability/Performance.</li>
          </ul>
        </div>`;

        // 6) Recommendations
        const weakest = (()=> {
          const vals = [
            {k:'Availability',v:avgAvail},
            {k:'Performance',v:avgPerf},
            {k:'Quality',v:Number(displayQuality)}
          ].filter(x=>Number.isFinite(x.v));
          if (!vals.length) return 'Availability';
          vals.sort((a,b)=>a.v-b.v);
          return vals[0].k;
        })();
        html += `<div class="card"><h3>7. Recommendations</h3>
          <ol style="text-align:left;line-height:1.6;">
            <li><strong>Preventive Maintenance:</strong> Schedule periodic checks for the most frequent downtime (<em>${topCode || 'N/A'}</em>) to prevent recurrence.</li>
            <li><strong>Training Support:</strong> Share quick-resolution SOPs with the operator for <em>${topCode || 'recurring faults'}</em> to reduce MTTR.</li>
            <li><strong>SKU Focus:</strong> Review machine settings and prep for SKUs that show higher downtime to stabilize changeovers and startup losses.</li>
            <li><strong>OEE Improvement Plan:</strong> Main loss driver appears to be <strong>${weakest}</strong>. Target a +4–5% OEE gain by addressing this first (optimize cycle time, minimize micro-stops, and enforce start-up checklists).</li>
          </ol>
        </div>`;

        // Render
        reportOutput.innerHTML = html;
        setStatus(`Report ready — rows used: ${rows.length}`);

        // Debug (optional)
        debugOutput.style.display = 'none';
        debugOutput.textContent =
`rows: ${rows.length}
runtime(min): ${totalRuntime}, downtime(min): ${totalDowntime}, idle(min): ${totalIdle}
plannedProduction: ${plannedProduction}, actual: ${actualProduction}, good: ${goodProduction}
energy[kWh] rt:${ecRuntime.toFixed(2)} dt:${ecDowntime.toFixed(2)} idle:${ecIdle.toFixed(2)} total:${ecTotal.toFixed(2)}
failures: ${totalFailures} overallMTBF:${(totalFailures? (totalRuntime/totalFailures):0).toFixed(1)} overallMTTR:${(totalFailures? (totalDurMinFromEvents/totalFailures):0).toFixed(1)}`;
      } catch (err) {
        showError(err.message || String(err)); setStatus('');
      }
    }
  </script>
</body>
</html>
