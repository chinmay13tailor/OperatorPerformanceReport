<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Operator Performance — select operator</title>
  <style>
    body{font-family:Inter,system-ui,Arial;margin:18px;background:#f4f6f8;color:#111}
    .wrap{max-width:1100px;margin:0 auto}
    h1{font-size:20px;text-align:center}
    .controls{display:flex;gap:10px;align-items:center;background:#fff;padding:12px;border-radius:10px;border:1px solid #e6e9ef}
    label{font-weight:600}
    input[type="date"]{padding:8px;border-radius:6px;border:1px solid #d1d5db}
    select{padding:8px;border-radius:6px;border:1px solid #d1d5db}
    button{padding:9px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;cursor:pointer;font-weight:700}
    button[disabled]{opacity:.6;cursor:not-allowed}
    .card{background:#fff;border-radius:10px;padding:14px;margin-top:14px;border:1px solid #e6e9ef}
    .muted{color:#6b7280}
    table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px}
    th,td{border:1px solid #e5e7eb;padding:8px;text-align:center}
    th{background:#fef3c7;position:sticky;top:0}
    .chips{display:flex;gap:8px;flex-wrap:wrap}
    .chip{background:#eef2ff;border:1px solid #c7d2fe;padding:6px 10px;border-radius:999px}
    .small{font-size:13px;color:#6b7280}
    .loader{width:14px;height:14px;border-radius:50%;border:2px solid #dbeafe;border-top-color:#2563eb;animation:spin .9s linear infinite;display:inline-block;vertical-align:-3px;margin-left:8px}
    @keyframes spin{to{transform:rotate(360deg)}}
    .error{background:#fff1f2;border:1px solid #fecaca;color:#7f1d1d;padding:10px;border-radius:8px;margin-top:10px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Operator Performance — Select Operator</h1>

    <!-- Controls -->
    <div class="controls" aria-label="controls">
      <label for="dateInput">Date</label>
      <input id="dateInput" type="date"/>
      <label for="operatorSelect">Select Operator</label>
      <select id="operatorSelect" disabled>
        <option>— pick a date first —</option>
      </select>
      <button id="btnGenerate" disabled>Generate</button>
      <div id="busy" style="margin-left:auto;display:none">
        Fetching <span class="loader"></span>
      </div>
    </div>

    <div id="errorBox" style="display:none" class="error"></div>

    <!-- Results -->
    <div id="results" class="card" style="display:none">
      <div id="summary"></div>
      <div id="skuSummary" style="margin-top:12px"></div>
      <div id="tableContainer" style="margin-top:12px;overflow:auto;max-height:420px">
        <table id="dataTable">
          <thead id="dataHead"></thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
/* ========== Configuration ========== */
const qs = new URLSearchParams(location.search);
const TOKEN = qs.get('token') || '';
const DEVICE_ID = qs.get('deviceId') || '991cf500-661a-11f0-90f1-775fee303094';
// ThingsBoard API base used in your reference
const API_BASE_URL = 'https://plantwiz.pimateck.in/api';

// Telemetry keys we will fetch (use underscore keys as per your telemetry)
const KEYS = [
  "SKU_Name","Operator_Name","Downtime_Submit","Downtime_Duration","Downtime_Reason_Code",
  "Machine_Speed","Standard_Speed","Runtime","Downtime","Idletime",
  "deltaperformance","deltaavailability","deltaoee"
].join(',');

/* ========== UI elements ========== */
const dateInput = document.getElementById('dateInput');
const operatorSelect = document.getElementById('operatorSelect');
const btnGenerate = document.getElementById('btnGenerate');
const busy = document.getElementById('busy');
const errorBox = document.getElementById('errorBox');
const results = document.getElementById('results');
const summary = document.getElementById('summary');
const skuSummary = document.getElementById('skuSummary');
const dataHead = document.getElementById('dataHead');
const dataBody = document.getElementById('dataBody');

/* ========== Helpers ========== */
function showBusy(flag){
  busy.style.display = flag ? 'block' : 'none';
  btnGenerate.disabled = flag || operatorSelect.disabled;
  operatorSelect.disabled = flag || operatorSelect.options.length === 0;
}
function showError(msg){
  if(!msg){ errorBox.style.display='none'; errorBox.textContent=''; return; }
  errorBox.style.display='block'; errorBox.textContent = msg;
}
function toRange(dateStr){
  const s = new Date(dateStr + 'T00:00:00');
  const e = new Date(dateStr + 'T23:59:59');
  return { startTs: s.getTime(), endTs: e.getTime() };
}
function safeNum(v){ const n = parseFloat(v); return Number.isFinite(n) ? n : 0; }
function unique(arr){ return [...new Set(arr.filter(x=>x!==null && x!==undefined && String(x).trim() !== ''))]; }

/* ========== Fetch timeseries utility ========== */
async function fetchTimeseries(deviceId, keys, startTs, endTs, limit=50000){
  const url = `${API_BASE_URL}/plugins/telemetry/DEVICE/${deviceId}/values/timeseries?keys=${encodeURIComponent(keys)}&startTs=${startTs}&endTs=${endTs}&limit=${limit}&agg=NONE`;
  const headers = TOKEN ? { 'X-Authorization': `Bearer ${TOKEN}` } : {};
  const res = await fetch(url, { headers });
  if(!res.ok){
    const text = await res.text().catch(()=>res.statusText);
    throw new Error(`API ${res.status} — ${text}`);
  }
  return res.json(); // returns object { key1: [{ts,value},...], key2: [...] }
}

/* ========== Map timeseries -> rows (ts keyed) ========== */
function buildRowsFromTimeseries(tsData){
  // tsData: {key: [{ts,value},...], ...}
  const map = new Map();
  Object.entries(tsData || {}).forEach(([key, arr])=>{
    (arr || []).forEach(p=>{
      const t = +p.ts;
      const row = map.get(t) || { ts: t };
      // keep original string values for some keys and numbers for numeric keys
      let val = p.value;
      // try parse numbers for known numeric keys:
      if(['Machine_Speed','Standard_Speed','Runtime','Downtime','Idletime','Downtime_Duration','deltaperformance','deltaavailability','deltaoee'].includes(key)){
        const n = parseFloat(p.value);
        val = Number.isFinite(n) ? n : p.value;
      }
      row[key] = val;
      map.set(t, row);
    });
  });
  // return sorted array of rows
  return Array.from(map.values()).sort((a,b)=>a.ts - b.ts);
}

/* ========== Step A: when date selected, fetch Operator_Name list and populate select ========== */
async function loadOperatorsForDate(dateStr){
  showError('');
  operatorSelect.innerHTML = '<option>Loading...</option>';
  operatorSelect.disabled = true;
  btnGenerate.disabled = true;
  results.style.display = 'none';

  const { startTs, endTs } = toRange(dateStr);
  try{
    showBusy(true);
    const tsData = await fetchTimeseries(DEVICE_ID, 'Operator_Name', startTs, endTs);
    const opArr = (tsData && tsData.Operator_Name) ? tsData.Operator_Name.map(d => String(d.value).trim()) : [];
    const uniqueOps = unique(opArr);
    operatorSelect.innerHTML = '';
    if(uniqueOps.length === 0){
      operatorSelect.innerHTML = '<option>— no operators found —</option>';
      operatorSelect.disabled = true;
      btnGenerate.disabled = true;
    } else {
      operatorSelect.appendChild(new Option('— select operator —', ''));
      uniqueOps.forEach(op => operatorSelect.appendChild(new Option(op, op)));
      operatorSelect.disabled = false;
      btnGenerate.disabled = false;
    }
  }catch(err){
    console.error(err);
    showError('Failed to load operators: ' + (err.message || err));
    operatorSelect.innerHTML = '<option>— error —</option>';
    operatorSelect.disabled = true;
    btnGenerate.disabled = true;
  }finally{
    showBusy(false);
  }
}

/* ========== Step B: when generate pressed, fetch all keys and filter rows by operator ========== */
async function generateForOperator(){
  showError('');
  results.style.display = 'none';
  dataHead.innerHTML = '';
  dataBody.innerHTML = '';

  const dateStr = dateInput.value;
  const operator = operatorSelect.value;
  if(!dateStr){ showError('Select date'); return; }
  if(!operator){ showError('Select operator'); return; }
  if(!TOKEN){ showError('Missing token in URL (?token=...)'); return; }

  const { startTs, endTs } = toRange(dateStr);
  try{
    showBusy(true);
    // fetch all KEYS for that day
    const tsData = await fetchTimeseries(DEVICE_ID, KEYS, startTs, endTs);
    const rows = buildRowsFromTimeseries(tsData);

    // filter rows where Operator_Name equals selected operator
    const filtered = rows.filter(r => {
      const val = (r.Operator_Name === undefined || r.Operator_Name === null) ? '' : String(r.Operator_Name).trim();
      return val === operator;
    });

    // If nothing found, show message
    if(filtered.length === 0){
      showError(`No telemetry rows found for operator "${operator}" on ${dateStr}.`);
      return;
    }

    // Build table header: show timestamp + a set of keys present in rows
    const columns = ['Timestamp',
      'SKU_Name','Machine_Speed','Runtime','Downtime','Idletime',
      'Downtime_Reason_Code','Downtime_Duration',
      'deltaperformance','deltaavailability','deltaoee'
    ];

    // render header
    dataHead.innerHTML = '<tr>' + columns.map(c => `<th>${c}</th>`).join('') + '</tr>';

    // render rows (limit to say 5000 rows to avoid UI freeze)
    const maxRows = 5000;
    const outRows = filtered.slice(0, maxRows);
    dataBody.innerHTML = outRows.map(r => {
      const ts = new Date(+r.ts).toLocaleString();
      const get = k => (r[k] !== undefined && r[k] !== null) ? r[k] : '--';
      return `<tr>
        <td>${ts}</td>
        <td>${get('SKU_Name')}</td>
        <td>${get('Machine_Speed')}</td>
        <td>${get('Runtime')}</td>
        <td>${get('Downtime')}</td>
        <td>${get('Idletime')}</td>
        <td>${get('Downtime_Reason_Code')}</td>
        <td>${get('Downtime_Duration')}</td>
        <td>${get('deltaperformance')}</td>
        <td>${get('deltaavailability')}</td>
        <td>${get('deltaoee')}</td>
      </tr>`;
    }).join('');

    // Summary: rows count, first/last timestamps
    const firstTs = new Date(+filtered[0].ts).toLocaleString();
    const lastTs = new Date(+filtered[filtered.length-1].ts).toLocaleString();
    summary.innerHTML = `
      <div><strong>Operator:</strong> ${operator}</div>
      <div class="small muted">Date: ${dateStr} · Rows: ${filtered.length} · First: ${firstTs} · Last: ${lastTs}</div>
    `;

    // SKU production summary (sum Machine_Speed grouped by SKU)
    const skuAgg = {};
    filtered.forEach(r => {
      const sku = (r.SKU_Name || 'UNSPECIFIED');
      const ms = safeNum(r.Machine_Speed);
      skuAgg[sku] = (skuAgg[sku] || 0) + ms;
    });
    skuSummary.innerHTML = `<div><strong>SKU production (sum Machine_Speed)</strong></div>
      <div class="chips">${Object.entries(skuAgg).map(([k,v])=>`<span class="chip">${k}: ${Number(v.toFixed ? v.toFixed(2) : v)}</span>`).join('')}</div>
    `;

    results.style.display = 'block';

  }catch(err){
    console.error(err);
    showError('Failed to fetch telemetry: ' + (err.message || err));
  } finally {
    showBusy(false);
  }
}

/* ========== wiring ========== */
dateInput.addEventListener('change', e => {
  showError('');
  operatorSelect.innerHTML = '<option>Loading...</option>';
  operatorSelect.disabled = true;
  btnGenerate.disabled = true;
  results.style.display = 'none';
  const dateStr = e.target.value;
  if(dateStr) loadOperatorsForDate(dateStr);
});

btnGenerate.addEventListener('click', generateForOperator);

/* ========== set default date (today) ========== */
(function setToday(){
  const tzNow = new Date();
  const y = tzNow.getFullYear();
  const m = String(tzNow.getMonth()+1).padStart(2,'0');
  const d = String(tzNow.getDate()).padStart(2,'0');
  dateInput.value = `${y}-${m}-${d}`;
  // auto-load operators for today
  loadOperatorsForDate(dateInput.value).catch(()=>{/*ignore*/});
})();
</script>
</body>
</html>
