<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Operator Performance Report</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; padding: 18px; background:#f7fafc; color:#111; }
    h2 { margin: 0 0 12px; }
    .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    input[type="date"], select { padding:8px 10px; border-radius:6px; border:1px solid #d1d5db; }
    button { padding:9px 12px; background:#2563eb; color:#fff; border:0; border-radius:8px; cursor:pointer; font-weight:600; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .card { background: #fff; padding:14px; border-radius:10px; border:1px solid #e6e9ef; margin-bottom:14px; }
    table { width:100%; border-collapse:collapse; margin-top:10px; font-size:13px; }
    th, td { padding:8px; border:1px solid #e6e9ef; text-align:center; }
    th { background:#f8fafc; font-weight:700; }
    .muted { color:#6b7280; font-size:13px; }
    .small { font-size:12px; color:#6b7280; }
    pre { background:#f3f4f6; padding:8px; border-radius:6px; overflow:auto; max-height:180px; }
    .error { color:#991b1b; background:#fff1f2; padding:8px; border-radius:6px; border:1px solid #fecaca; margin-top:8px; }
  </style>
</head>
<body>
  <h2>Operator Performance Report</h2>
  <div class="controls">
    <label for="datePicker">Date</label>
    <input id="datePicker" type="date" />
    <label for="operatorSelect">Operator</label>
    <select id="operatorSelect"><option value="">-- Select Operator --</option></select>
    <button id="generateBtn">Generate</button>
    <div id="status" class="small muted" style="margin-left:12px"></div>
  </div>

  <div id="errorBox" style="display:none" class="error"></div>
  <div id="reportOutput"></div>
  <pre id="debugOutput" style="display:none"></pre>

  <script>
    /* ---------- Configuration ---------- */
    const DEVICE_ID = "991cf500-661a-11f0-90f1-775fee303094";
    const API_BASE = "https://plantwiz.pimateck.in/api";
    const qs = new URLSearchParams(window.location.search);
    const TOKEN = qs.get('token') || "";

    /* ---------- DOM ---------- */
    const datePicker = document.getElementById('datePicker');
    const operatorSelect = document.getElementById('operatorSelect');
    const btnGenerate = document.getElementById('generateBtn');
    const status = document.getElementById('status');
    const reportOutput = document.getElementById('reportOutput');
    const errorBox = document.getElementById('errorBox');
    const debugOutput = document.getElementById('debugOutput');

    /* ---------- Helpers ---------- */
    function showError(msg) {
      if (!msg) { errorBox.style.display = 'none'; errorBox.textContent = ''; return; }
      errorBox.style.display = 'block'; errorBox.textContent = msg;
    }
    function setStatus(txt) { status.textContent = txt || ''; }
    function safeNum(v) {
      if (v === undefined || v === null || v === "") return NaN;
      const n = typeof v === 'number' ? v : parseFloat(String(v).replace(',', ''));
      return Number.isFinite(n) ? n : NaN;
    }
    function normalizeToMinute(ts) {
      const d = new Date(+ts);
      d.setSeconds(0, 0);
      return d.getTime();
    }

    /* ---------- Telemetry keys ---------- */
    const KEYS_LIST = [
      "SKU","Operator_Name","Downtime_Submit","Downtime_Duration","Downtime_Reason_Code",
      "Machine_Speed","Standard_Speed","Runtime","Downtime","Idletime",
      "deltaperformance","deltaavailability","deltaoee","deltaquality",
      "Good_Production","Planned_Production","Planned_Production_Time"
    ];
    const KEYS_PARAM = KEYS_LIST.join(',');

    /* ---------- Fetch timeseries ---------- */
    async function fetchTelemetryForDate(dateStr) {
      if (!TOKEN) throw new Error("Missing token in URL (?token=YOUR_JWT)");
      const start = new Date(dateStr + "T00:00:00").getTime();
      const end = new Date(dateStr + "T23:59:59").getTime();
      const url = `${API_BASE}/plugins/telemetry/DEVICE/${DEVICE_ID}/values/timeseries?keys=${encodeURIComponent(KEYS_PARAM)}&startTs=${start}&endTs=${end}&interval=60000&limit=5000`;
      const res = await fetch(url, { headers: { "X-Authorization": `Bearer ${TOKEN}` } });
      if (!res.ok) {
        const txt = await res.text().catch(()=>res.statusText);
        throw new Error(`Telemetry fetch failed: ${res.status} ${txt}`);
      }
      return res.json();
    }

    /* ---------- Build rows ---------- */
    function buildRowsFromTimeseries(tsObj) {
      const map = new Map();
      Object.entries(tsObj || {}).forEach(([key, arr])=>{
        (arr || []).forEach(p=>{
          const minute = normalizeToMinute(p.ts);
          const row = map.get(minute) || { ts: minute };
          row[key] = p.value;
          map.set(minute, row);
        });
      });
      return Array.from(map.values()).sort((a,b)=>a.ts-b.ts);
    }

    /* ---------- Load operators ---------- */
    async function loadOperators(dateStr) {
      try {
        showError('');
        setStatus('Loading operators…');
        operatorSelect.innerHTML = '<option value="">Loading…</option>';
        const ts = await fetchTelemetryForDate(dateStr);
        const ops = (ts.Operator_Name || []).map(x => String(x.value).trim()).filter(s => s);
        const unique = [...new Set(ops)];
        operatorSelect.innerHTML = '<option value="">-- Select Operator --</option>';
        unique.forEach(op => operatorSelect.appendChild(new Option(op, op)));
        setStatus(unique.length ? `Found ${unique.length} operator(s)` : 'No operators found');
      } catch (err) {
        operatorSelect.innerHTML = '<option value="">-- Select Operator --</option>';
        showError(err.message || String(err));
        setStatus('');
        console.error(err);
      }
    }

    /* ---------- Generate report ---------- */
    async function generateReport() {
      showError('');
      reportOutput.innerHTML = '';
      debugOutput.style.display = 'none';

      const dateStr = datePicker.value;
      const operator = operatorSelect.value;
      if (!dateStr) { showError('Please select a date.'); return; }
      if (!operator) { showError('Please select an operator.'); return; }

      try {
        setStatus('Fetching telemetry and computing report…');
        const ts = await fetchTelemetryForDate(dateStr);
        const rows = buildRowsFromTimeseries(ts);

        const opRows = rows.filter(r => {
          const v = r.Operator_Name === undefined || r.Operator_Name === null ? '' : String(r.Operator_Name).trim();
          return v === operator;
        });

        if (opRows.length === 0) {
          reportOutput.innerHTML = `<div class="card"><div class="muted">No records found for ${operator} on ${dateStr}.</div></div>`;
          setStatus('');
          return;
        }

        const skuAgg = {};
        let totalRuntime = 0, totalDowntime = 0, totalIdle = 0;
        let actualProduction = 0, goodProduction = 0, plannedProduction = 0, plannedTime = 0;
        let sumPerf = 0, cntPerf = 0;
        let sumAvail = 0, cntAvail = 0;
        let sumOee = 0, cntOee = 0;
        let sumQualityDelta = 0, cntQualityDelta = 0;

        opRows.forEach(r => {
          const sku = (r.SKU && String(r.SKU).trim()) || 'UNSPECIFIED';
          const ms = safeNum(r.Machine_Speed);
          const stdSpeed = safeNum(r.Standard_Speed);
          const rt = safeNum(r.Runtime);
          const dt = safeNum(r.Downtime);
          const it = safeNum(r.Idletime);

          if (!skuAgg[sku]) skuAgg[sku] = { production: 0, runtime: 0, downtime: 0, idletime: 0 };
          skuAgg[sku].production += Number.isFinite(ms) ? ms : 0;
          skuAgg[sku].runtime += Number.isFinite(rt) ? rt : 0;
          skuAgg[sku].downtime += Number.isFinite(dt) ? dt : 0;
          skuAgg[sku].idletime += Number.isFinite(it) ? it : 0;

          totalRuntime += Number.isFinite(rt) ? rt : 0;
          totalDowntime += Number.isFinite(dt) ? dt : 0;
          totalIdle += Number.isFinite(it) ? it : 0;

          actualProduction += Number.isFinite(ms) ? ms : 0;
          goodProduction += Number.isFinite(safeNum(r.Good_Production)) ? safeNum(r.Good_Production) : 0;
          plannedProduction += Number.isFinite(stdSpeed) ? stdSpeed : 0;
          plannedTime = Number.isFinite(safeNum(r.Planned_Production_Time)) ? safeNum(r.Planned_Production_Time) : plannedTime;

          const dp = safeNum(r.deltaperformance); if (Number.isFinite(dp)) { sumPerf += dp; cntPerf++; }
          const da = safeNum(r.deltaavailability); if (Number.isFinite(da)) { sumAvail += da; cntAvail++; }
          const doee = safeNum(r.deltaoee); if (Number.isFinite(doee)) { sumOee += doee; cntOee++; }
          const dq = safeNum(r.deltaquality); if (Number.isFinite(dq)) { sumQualityDelta += dq; cntQualityDelta++; }
        });

        const avgPerf = cntPerf ? (sumPerf / cntPerf) : NaN;
        const avgAvail = cntAvail ? (sumAvail / cntAvail) : NaN;
        const avgOee = cntOee ? (sumOee / cntOee) : NaN;
        const avgQualityDelta = cntQualityDelta ? (sumQualityDelta / cntQualityDelta) : NaN;
        const computedQualityPct = actualProduction ? (goodProduction / actualProduction * 100) : NaN;
        const displayQuality = Number.isFinite(avgQualityDelta) ? avgQualityDelta : computedQualityPct;

        let html = '';

        // 1) Production Details
        html += `<div class="card"><h3>Production Details (SKU-wise)</h3>`;
        html += `<table><thead><tr><th>SKU Name</th><th>Production (Units)</th><th>Runtime (hrs)</th><th>Downtime (hrs)</th><th>Idletime (hrs)</th></tr></thead><tbody>`;
        for (const sku of Object.keys(skuAgg)) {
          const d = skuAgg[sku];
          html += `<tr>
            <td>${sku}</td>
            <td>${Number(d.production).toFixed(2)}</td>
            <td>${(Number(d.runtime) / 60).toFixed(2)}</td>
            <td>${(Number(d.downtime) / 60).toFixed(2)}</td>
            <td>${(Number(d.idletime) / 60).toFixed(2)}</td>
          </tr>`;
        }
        html += `</tbody></table></div>`;

        // 2) Machine Performance Summary
        html += `<div class="card"><h3>Machine Performance Summary</h3>`;
        html += `<table><thead><tr><th>OEE</th><th>Performance</th><th>Availability</th><th>Quality</th></tr></thead><tbody>`;
        html += `<tr>
          <td>${Number.isFinite(avgOee) ? avgOee.toFixed(2) + '%' : '--'}</td>
          <td>${Number.isFinite(avgPerf) ? avgPerf.toFixed(2) + '%' : '--'}</td>
          <td>${Number.isFinite(avgAvail) ? avgAvail.toFixed(2) + '%' : '--'}</td>
          <td>${Number.isFinite(displayQuality) ? Number(displayQuality).toFixed(2) + '%' : '--'}</td>
        </tr></tbody></table>`;

        html += `<table style="margin-top:10px;"><thead><tr>
          <th>Planned Production</th><th>Planned Production Time (min)</th><th>Actual Production</th>
          <th>Runtime (hrs)</th><th>Good Production</th><th>Downtime (hrs)</th>
        </tr></thead><tbody>`;
        html += `<tr>
          <td>${Number.isFinite(plannedProduction) ? plannedProduction.toFixed(0) : '--'}</td>
          <td>${Number.isFinite(plannedTime) ? plannedTime.toFixed(0) : '--'}</td>
          <td>${actualProduction.toFixed(0)}</td>
          <td>${(totalRuntime / 60).toFixed(2)}</td>
          <td>${goodProduction.toFixed(0)}</td>
          <td>${(totalDowntime / 60).toFixed(2)}</td>
        </tr></tbody></table></div>`;

        // 3) Downtime Summary (Duration in minutes; source is seconds)
        const dtByReason = {};
        let failures = 0;
        opRows.forEach(r => {
          const submit = safeNum(r.Downtime_Submit);
          if (submit === 1) {
            const reason = r.Downtime_Reason_Code ? String(r.Downtime_Reason_Code).trim() : 'UNKNOWN';
            let durMin = safeNum(r.Downtime_Duration);
            // convert SECONDS -> MINUTES
            durMin = Number.isFinite(durMin) ? (durMin / 60) : durMin;
            if (!dtByReason[reason]) dtByReason[reason] = { occ: 0, totalMin: 0, mttrSamples: [] };
            dtByReason[reason].occ += 1;
            if (Number.isFinite(durMin)) {
              dtByReason[reason].totalMin += durMin;
              dtByReason[reason].mttrSamples.push(durMin);
            }
            failures++;
          }
        });
        Object.values(dtByReason).forEach(obj => {
          obj.mttr = obj.mttrSamples.length ? (obj.mttrSamples.reduce((a,b)=>a+b,0)/obj.mttrSamples.length) : NaN;
          // MTBF approximation: total runtime minutes / occurrences
          obj.mtbf = obj.occ ? (totalRuntime / obj.occ) : NaN;
        });
        const overallMTTR = failures ? (Object.values(dtByReason).reduce((a,b)=>a+b.totalMin,0) / failures) : NaN;
        const overallMTBF = failures ? (totalRuntime / failures) : NaN;

        let dtRows = '';
        Object.entries(dtByReason).forEach(([reason,obj],i)=>{
          const dtId = `D-${String(101+i).padStart(3,'0')}`;
          dtRows += `<tr>
            <td>${dtId}</td>
            <td>${reason}</td>
            <td>${Number(obj.totalMin).toFixed(0)}</td>
            <td>${obj.occ}</td>
            <td>${Number.isFinite(obj.mtbf)? obj.mtbf.toFixed(0):'--'}</td>
            <td>${Number.isFinite(obj.mttr)? obj.mttr.toFixed(0):'--'}</td>
          </tr>`;
        });

        html += `
          <div class="card">
            <h3>Alarms & Downtimes During Operation</h3>
            <h4>Downtime Summary</h4>
            <table>
              <thead><tr>
                <th>Downtime ID</th>
                <th>Downtime Reason</th>
                <th>Downtime Duration (min)</th>
                <th>No. of Times</th>
                <th>MTBF (min)</th>
                <th>MTTR (min)</th>
              </tr></thead>
              <tbody>
                ${dtRows || '<tr><td colspan="6" class="muted">No downtime events</td></tr>'}
              </tbody>
            </table>
            <div class="small muted" style="margin-top:6px">
              Overall Operator MTBF: ${Number.isFinite(overallMTBF)? overallMTBF.toFixed(0):'--'} min
              &nbsp; | &nbsp;
              Overall Operator MTTR: ${Number.isFinite(overallMTTR)? overallMTTR.toFixed(0):'--'} min
            </div>
          </div>`;

        reportOutput.innerHTML = html;

        debugOutput.style.display = 'block';
        debugOutput.textContent = `Averages computed from counts:\n`+
          `deltaperformance → count=${cntPerf}\n`+
          `deltaavailability → count=${cntAvail}\n`+
          `deltaoee → count=${cntOee}\n`+
          `deltaquality → count=${cntQualityDelta}`;

        setStatus(`Report ready — rows used: ${opRows.length}`);
      } catch (err) {
        showError(err.message || String(err));
        setStatus('');
        console.error(err);
      }
    }

    /* ---------- Event bindings ---------- */
    datePicker.addEventListener('change', () => {
      setStatus('');
      showError('');
      const date = datePicker.value;
      if (!date) return;
      loadOperators(date);
    });

    btnGenerate.addEventListener('click', generateReport);

    (function setToday(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      datePicker.value = `${y}-${m}-${day}`;
      if (datePicker.value) loadOperators(datePicker.value).catch(()=>{});
    })();
  </script>
</body>
</html>
