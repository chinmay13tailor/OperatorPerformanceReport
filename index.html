<!DOCTYPE html>
<html>
<head>
  <title>Operator Performance Report</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    h2 { color: #333; }
    select, input, button { padding: 8px; margin: 10px; font-size: 14px; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    table, th, td { border: 1px solid #ccc; }
    th, td { padding: 8px; text-align: center; }
    th { background: #f4f4f4; }
    pre { background: #f4f4f4; padding: 10px; border-radius: 5px; max-height: 500px; overflow: auto; }
  </style>
</head>
<body>
  <h2>Operator Performance Report</h2>
  
  <label for="datePicker">Select Date:</label>
  <input type="date" id="datePicker">

  <label for="operatorSelect">Select Operator:</label>
  <select id="operatorSelect">
    <option value="">-- Select Operator --</option>
  </select>

  <button id="generateBtn">Generate Report</button>

  <div id="reportOutput"></div>
  <pre id="debugOutput"></pre>

  <script>
    const deviceId = "991cf500-661a-11f0-90f1-775fee303094";
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');

    const datePicker = document.getElementById("datePicker");
    const operatorSelect = document.getElementById("operatorSelect");
    const reportOutput = document.getElementById("reportOutput");
    const debugOutput = document.getElementById("debugOutput");

    function normalizeToMinute(timestamp) {
      let date = new Date(timestamp);
      date.setSeconds(0, 0);
      return date.getTime();
    }

    async function fetchTelemetry(date) {
      let start = new Date(date + "T00:00:00").getTime();
      let end = new Date(date + "T23:59:59").getTime();
      const url = `https://plantwiz.pimateck.in/api/plugins/telemetry/DEVICE/${deviceId}/values/timeseries?keys=SKU,Operator_Name,Downtime_Submit,Downtime_Duration,Downtime_Reason_Code,Machine_Speed,Standard_Speed,Runtime,Downtime,Idletime,deltaperformance,deltaavailability,deltaoee,Good_Production,Planned_Production,Planned_Production_Time&startTs=${start}&endTs=${end}&interval=60000&limit=5000`;

      const response = await fetch(url, {
        headers: { "X-Authorization": `Bearer ${token}` }
      });

      if (!response.ok) throw new Error(`Failed to fetch telemetry: ${response.statusText}`);
      return await response.json();
    }

    datePicker.addEventListener("change", async () => {
      let date = datePicker.value;
      if (!date) return;

      debugOutput.textContent = "Fetching operators...";
      try {
        let telemetry = await fetchTelemetry(date);

        let operatorSet = new Set();
        if (telemetry.Operator_Name) {
          telemetry.Operator_Name.forEach(item => operatorSet.add(item.value));
        }

        operatorSelect.innerHTML = '<option value="">-- Select Operator --</option>';
        operatorSet.forEach(op => {
          let option = document.createElement("option");
          option.value = op;
          option.textContent = op;
          operatorSelect.appendChild(option);
        });

        debugOutput.textContent = "Operators loaded. Please select one.";
      } catch (error) {
        debugOutput.textContent = `Error: ${error.message}`;
      }
    });

    document.getElementById("generateBtn").addEventListener("click", async () => {
      let date = datePicker.value;
      let operator = operatorSelect.value;
      if (!date || !operator) {
        debugOutput.textContent = "Please select a date and an operator.";
        return;
      }

      debugOutput.textContent = `Generating report for ${operator} on ${date}...`;

      try {
        let telemetry = await fetchTelemetry(date);

        // Group telemetry by minute
        let groupedData = {};
        const keys = [
          "SKU", "Operator_Name", "Downtime_Submit", "Downtime_Duration",
          "Downtime_Reason_Code", "Machine_Speed", "Standard_Speed",
          "Runtime", "Downtime", "Idletime",
          "deltaperformance", "deltaavailability", "deltaoee",
          "Good_Production", "Planned_Production", "Planned_Production_Time"
        ];

        keys.forEach(key => {
          if (!telemetry[key]) return;
          telemetry[key].forEach(entry => {
            let minute = normalizeToMinute(entry.ts);
            if (!groupedData[minute]) groupedData[minute] = {};
            groupedData[minute][key] = entry.value;
          });
        });

        // Filter records for selected operator
        let operatorData = Object.entries(groupedData)
          .filter(([minute, data]) => data.Operator_Name === operator)
          .map(([minute, data]) => ({
            time: new Date(parseInt(minute)).toLocaleTimeString(),
            ...data
          }));

        // Aggregate SKU-wise data
        let skuSummary = {};
        let oee = 0, performance = 0, availability = 0, quality = 0;
        let plannedProduction = 0, plannedTime = 0, actualProduction = 0, goodProduction = 0;
        let totalRuntime = 0, totalDowntime = 0;

        operatorData.forEach(row => {
          let sku = row.SKU || "Unknown";
          if (!skuSummary[sku]) {
            skuSummary[sku] = { production: 0, runtime: 0, downtime: 0, idletime: 0 };
          }
          skuSummary[sku].production += row.Machine_Speed ? parseFloat(row.Machine_Speed) : 0;
          skuSummary[sku].runtime += row.Runtime ? parseFloat(row.Runtime) : 0;
          skuSummary[sku].downtime += row.Downtime ? parseFloat(row.Downtime) : 0;
          skuSummary[sku].idletime += row.Idletime ? parseFloat(row.Idletime) : 0;

          // OEE KPIs (taking the last recorded value for simplicity)
          if (row.deltaperformance) performance = parseFloat(row.deltaperformance);
          if (row.deltaavailability) availability = parseFloat(row.deltaavailability);
          if (row.deltaoee) oee = parseFloat(row.deltaoee);

          // Production details
          if (row.Planned_Production) plannedProduction = parseFloat(row.Planned_Production);
          if (row.Planned_Production_Time) plannedTime = parseFloat(row.Planned_Production_Time);
          if (row.Machine_Speed) actualProduction += parseFloat(row.Machine_Speed);
          if (row.Good_Production) goodProduction += parseFloat(row.Good_Production);

          totalRuntime += row.Runtime ? parseFloat(row.Runtime) : 0;
          totalDowntime += row.Downtime ? parseFloat(row.Downtime) : 0;
        });

        quality = actualProduction > 0 ? ((goodProduction / actualProduction) * 100) : 0;

        // Build SKU-wise table
        let tableHTML = `
          <h3>Production Details (SKU-wise)</h3>
          <table>
            <tr>
              <th>SKU</th>
              <th>Production (Units)</th>
              <th>Runtime (hrs)</th>
              <th>Downtime (hrs)</th>
              <th>Idletime (hrs)</th>
            </tr>
        `;

        for (let sku in skuSummary) {
          let data = skuSummary[sku];
          tableHTML += `
            <tr>
              <td>${sku}</td>
              <td>${data.production.toFixed(2)}</td>
              <td>${(data.runtime / 60).toFixed(2)}</td>
              <td>${(data.downtime / 60).toFixed(2)}</td>
              <td>${(data.idletime / 60).toFixed(2)}</td>
            </tr>
          `;
        }

        tableHTML += `</table>`;

        // Build Machine Performance Summary table
        tableHTML += `
          <h3>Machine Performance Summary</h3>
          <table>
            <tr>
              <th>OEE</th>
              <th>Performance</th>
              <th>Availability</th>
              <th>Quality</th>
            </tr>
            <tr>
              <td>${oee.toFixed(2)}%</td>
              <td>${performance.toFixed(2)}%</td>
              <td>${availability.toFixed(2)}%</td>
              <td>${quality.toFixed(2)}%</td>
            </tr>
          </table>
          <table>
            <tr>
              <th>Planned Production</th>
              <th>Planned Production Time (min)</th>
              <th>Actual Production</th>
              <th>Runtime (hrs)</th>
              <th>Good Production</th>
              <th>Downtime (hrs)</th>
            </tr>
            <tr>
              <td>${plannedProduction.toFixed(0)}</td>
              <td>${plannedTime.toFixed(0)}</td>
              <td>${actualProduction.toFixed(0)}</td>
              <td>${(totalRuntime / 60).toFixed(2)}</td>
              <td>${goodProduction.toFixed(0)}</td>
              <td>${(totalDowntime / 60).toFixed(2)}</td>
            </tr>
          </table>
        `;

        reportOutput.innerHTML = tableHTML;
        debugOutput.textContent = "Report generated successfully.";
      } catch (error) {
        debugOutput.textContent = `Error generating report: ${error.message}`;
      }
    });
  </script>
</body>
</html>
